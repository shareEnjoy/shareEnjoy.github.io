[{"title":"Spring Boot与日志","date":"2020-03-12T02:47:23.000Z","path":"2020/03/12/spring-boot-logging/","text":"1.日志框架​ 一个统一的接口层；日志门面（日志的一个抽象层）； ​ 给项目中导入具体的日志实现就行了；之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…… 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ SpringBoot选用 SLF4j和logback； 2.SLF4j使用1、如何在系统中使用SLF4j用户文档 以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； 1、将系统中其他日志框架先排除出去； 2、用中间包来替换原有的日志框架； 3、我们导入slf4j其他的实现; 3.SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(\"rawtypes\")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可； 4.日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\");&#125; 12345678910 &lt;-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot修改日志的默认配置： 1234567891011121314151617181920logging.level.com.atguigu=trace#logging.path=(过时)# 在当前项目下生成my.log日志logging.file.name=my.log#logging.file=G:/springboot.log(过时)#logging.file.path= 文件名 直接在跟目录下创建该文件且自动 帮你创建好 spring.log 文件logging.file.name=/log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log(过时)# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file.name logging.file.name Example Description (none) (none) 仅控制台记录。 指定文件名 (none) my.log 写入指定的日志文件。名称可以是确切的位置，也可以相对于当前目录。 (none) 指定目录 /var/log 写入spring.log指定的目录。名称可以是确切的位置，也可以相对于当前目录。 2、指定配置官方日志文档；给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties 官方建议将-spring变体用于日志记录配置（例如，logback-spring.xml而不是logback.xml）。如果使用标准配置位置，Spring将无法完全控制日志初始化。 如果用logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误: 1no applicable action for [springProfile] 5.切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式: 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2: 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quietair.gitee.io/tags/SpringBoot/"}]},{"title":"Spring Boot配置文件解析","date":"2020-03-05T07:46:27.000Z","path":"2020/03/05/spring-boot-configuration/","text":"1.配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2.YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔） ​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 3、对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 4、数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3.配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL(Spring表达式) 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(\"配置类@Bean给容器中添加组件了...\"); return new HelloService(); &#125;&#125; ##4、配置文件占位符 1、随机数 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值 123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 4.ProfileProfile是spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境。 1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式12345678910111213141516171819server: port: 8081spring: profiles: active: prod #指定激活哪个环境---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 5.配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 123#application.properties文件内容server.post=8081#server.servlet.context-path=/boot #配置项目得访问路径 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar G:/application.properties 6.外部配置加载顺序SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找； 优先加载带profile 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 7.自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件; 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()//扫描所有jar包类路径下 META-INF/spring.factories//把扫描到的这些文件的内容包装成properties对象//从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 1234567891011121314151617181920212223242526272829@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节@Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition)","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quietair.gitee.io/tags/SpringBoot/"}]},{"title":"Spring Boot入门","date":"2020-02-29T12:24:00.000Z","path":"2020/02/29/spring-boot-01/","text":"1.Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2.微服务微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3.环境准备环境约束: –jdk1.8：Spring Boot 推荐jdk1.7及以上； –maven3.x：maven 3.3以上版本； –IntelliJIDEA：IntelliJ IDEA –SpringBoot 1.5.9.RELEASE：1.5.9； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加(可以添加，也可以不用)； 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置首先对maven进行整合； 4.Spring Boot HelloWorld实现一个简单的功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // 把Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，再window下或者Linux下直接使用java -jar的命令进行执行； 5.Hello World探究1.POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;上面的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;它来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； 总结：Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2.主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； 将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器； ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； 总结：Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； 6.IDEA：使用 Spring Initializer快速创建spring boot项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quietair.gitee.io/tags/SpringBoot/"}]},{"title":"双十一淘宝刷喵币、京东养红包脚本","date":"2019-10-24T07:24:00.000Z","path":"2019/10/24/tianmao/","text":"一、2019双十一淘宝刷喵币脚本上一个版本不能用了，目前只能用安卓手机的了。 1.下载并安装Auto.js到应用商店去搜索下载就行，也可以去官网:https://hyb1996.github.io/AutoJs-Docs 2.为软件打开无障碍权限.打开无障碍后，在软件中将下面脚本保存并运行即可,脚本会自己打开手机淘宝并进行一系列的操作. 3.将下面脚本复制到上一步文件中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172auto.waitFor()var appRun = currentActivity()var t=0if(appRun != 'com.taobao.taobao') &#123; launchApp(\"手机淘宝\") toast(\"打开手机淘宝中\"); sleep(5000)&#125;function run() &#123; className(\"android.view.View\").desc(\"搜索\").clickable(true).findOne().click() sleep(2000) id(\"searchEdit\").waitFor() sleep(500) id(\"searchEdit\").findOne().setText(\"双十一合伙人\") sleep(1000) id(\"searchbtn\").findOne().click() sleep(5000) className(\"android.view.View\").depth(18).boundsInside(device.width /2, device.height / 2, device.width, device.height).clickable(true).findOne().click() sleep(3000) if (text(\"签到\").exists()) &#123; text(\"签到\").findOne().click(); sleep(1600); toast(\"签到成功\") &#125;; while(text(\"去进店\").exists()) &#123; toast(\"开始进行 去进店 任务！\") goShop() &#125;; if(text(\"去浏览\").exists()) &#123; toast(\"开始进行 去浏览 任务！\") goBrowse() &#125;; toast(\"今日任务已完成！\"); &#125;function goShop() &#123; let x = device.width / 2, y = device.height / 5; text(\"去进店\").findOne().click() toast(\"点击去进店\") sleep(2000) if(desc(\"签到领喵币\").exists())&#123; var b = desc(\"签到领喵币\").findOne().bounds(); click(b.centerX(), b.centerY()); sleep(1000) className(\"android.widget.ImageView\").depth(10).drawingOrder(2).findOne().click() &#125; var task = className('android.view.View').depth(11).desc('任务完成').exists() while(!task) &#123; swipe(x, 4*y, x, y,1000); sleep(3000) task = className('android.view.View').depth(11).desc('任务完成').exists() || className('android.view.View').depth(18).desc('任务完成').exists(); if (task) toast('任务完成'); &#125; back() toast(\"已经逛了\" + ++t + \"次\") sleep(2000)&#125;function goBrowse() &#123; while (text(\"去浏览\").exists()) &#123; //判断是否有去浏览 text(\"去浏览\").findOne().click(); sleep(23000) back() toast(\"已经逛了\" + ++t + \"次\") sleep(2000) &#125;&#125;run() 二、2019双十一京东养红包脚本4.打开浏览器，登陆京东点击https://www.jd.com 5.打开下面这个网页点击https://happy.m.jd.com/babelDiy/GZWVJFLMXBQVEBDQZWMY/XJf8bH6oXDWSgS91daDJzXh9bU7/index.html#/index 6.按F12在Console里面输入下面代码，点击回车将下面代码复制Console里面去回车,然后info里就能看到效果，挂后台就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990let productList = [], shopList = [], url = \"https://api.m.jd.com/client.action\";function autoPost(id,type)&#123; fetch(`$&#123;url&#125;?timestamp=$&#123;new Date().getTime()&#125;`,&#123;method: \"POST\",mode: \"cors\",credentials: \"include\",headers:&#123;\"Content-Type\": \"application/x-www-form-urlencoded\"&#125;,body:`functionId=raisepacket_collectScore&amp;body=&#123;\"type\":$&#123;type&#125;,\"ext\":\"$&#123;id&#125;\",\"appsign\":1,\"msgsign\":2&#125;&amp;client=wh5`&#125;) .then(function(response)&#123;return response.json()&#125;) .then(function(res)&#123; console.log(res.data.biz_msg); &#125;);&#125;function start()&#123; fetch(`$&#123;url&#125;?$&#123;new Date().getTime()&#125;`,&#123;method: \"POST\",mode: \"cors\",credentials: \"include\",headers:&#123;\"Content-Type\": \"application/x-www-form-urlencoded\"&#125;,body:'functionId=raisepacket_getShopAndProductList&amp;body=&amp;client=wh5'&#125;) .then(function(response)&#123;return response.json()&#125;) .then(function(res)&#123; productList = res.data.result.productList; shopList = res.data.result.shopList; console.log(`获取到任务,商品：$&#123;productList.length&#125; 商品：$&#123;shopList.length&#125;by：ke`); autoProductTask(); &#125;);&#125;//逛商品function autoProductTask()&#123; for(let i = 0,leng = productList.length;i&lt;leng;i++)&#123; (function(index)&#123; setTimeout(()=&gt;&#123; let item = productList[index]; autoPost(item['id'],4); console.log(`商品总任务数：$&#123;leng&#125; 当前任务数：$&#123;index + 1&#125;by：ke`); if( leng-1 == index)&#123; autoShopTask(); &#125; &#125;,index*1500) &#125;)(i) &#125;&#125;//逛店铺function autoShopTask()&#123; for(let i = 0,leng = shopList.length;i&lt;leng;i++)&#123; (function(index)&#123; setTimeout(()=&gt;&#123; let item = shopList[index]; autoPost(item['id'],2); console.log(`商铺总任务数：$&#123;leng&#125; 当前任务数：$&#123;index + 1&#125;by：ke`); if( leng-1 == index)&#123; autoPlay(); &#125; &#125;,index*1500) &#125;)(i) &#125;&#125;//好玩互动function autoPlay()&#123; for(let i = 0,leng = 4;i&lt;leng;i++)&#123; (function(index)&#123; setTimeout(()=&gt;&#123; autoPost(0,5); console.log(`好玩互动：$&#123;leng&#125; 当前任务数：$&#123;index + 1&#125;by：ke`); if( leng-1 == index)&#123; autoInteract(); &#125; &#125;,index*1000) &#125;)(i) &#125;&#125;//视频直播function autoInteract()&#123; for(let i = 0,leng = 4;i&lt;leng;i++)&#123; (function(index)&#123; setTimeout(()=&gt;&#123; autoPost(0,10); console.log(`视频直播：$&#123;leng&#125; 当前任务数：$&#123;index + 1&#125;by：ke`); if( leng-1 == index)&#123; autoShopping(); &#125; &#125;,index*1000) &#125;)(i) &#125;&#125;//精彩会场function autoShopping()&#123; for(let i = 0,leng = 3;i&lt;leng;i++)&#123; (function(index)&#123; setTimeout(()=&gt;&#123; autoPost(0,3); console.log(`精彩会场：$&#123;leng&#125; 当前任务数：$&#123;index + 1&#125;by：ke`); &#125;, index*1000) &#125;)(i) &#125;&#125;start();","tags":[{"name":"Share","slug":"Share","permalink":"https://quietair.gitee.io/tags/Share/"}]},{"title":"怎么查看ubuntu是32位还是64位","date":"2019-10-17T07:56:33.000Z","path":"2019/10/17/ubuntu-see-64or32bit/","text":"一、查看操作系统是32位的还是64位的在控制台输入： 1$ sudo uname --m 回车后：如果显示i686,则表示安装了32位操作系统如果显示 x86_64，则表示安装了64位操作系统 二、如果想知道更多信息可以试试如下命令：1234$ sudo uname --s #显示内核名字$ sudo uname --r #显示内核版本$ sudo uname --n #显示网络主机名$ sudo uname --p #显示cpu","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://quietair.gitee.io/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"https://quietair.gitee.io/tags/Linux/"}]},{"title":"jQuery.validator.addMethod自定义验证规则","date":"2019-10-09T05:51:19.000Z","path":"2019/10/09/jQuery-validator-addMethod/","text":"jQuery.validate是一款非常不错的表单验证工具，简单易上手，而且能达到很好的体验效果 一、用前必备官方网站：http://bassistance.de/jquery-plugins/jquery-plugin-validation/（注意下载最新版）需要JQuery版本：1.2.6+, 兼容 1.3.2 12&lt;script src=\"../js/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script src=\"../js/jquery.validate.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 二、默认校验规则1234567891011121314151617required:true #必输字段remote:\"check.php\" #使用ajax方法调用check.php验证输入值email:true #必须输入正确格式的电子邮件url:true #必须输入正确格式的网址date:true #必须输入正确格式的日期dateISO:true #必须输入正确格式的日期(ISO)，例如：2009-06-23，1998/01/22 只验证格式，不验证有效性number:true #必须输入合法的数字(负数，小数)digits:true #必须输入整数creditcard: #必须输入合法的信用卡号equalTo:\"#field\" #输入值必须和#field相同accept: #输入拥有合法后缀名的字符串（上传文件的后缀）maxlength:5 #输入长度最多是5的字符串(汉字算一个字符)minlength:10 #输入长度最小是10的字符串(汉字算一个字符)rangelength:[5,10] #输入长度必须介于 5 和 10 之间的字符串\")(汉字算一个字符)range:[5,10] #输入值必须介于 5 和 10 之间max:5 #输入值不能大于5min:10 #输入值不能小于10 三、默认的提示123456789101112131415161718192021222324252627282930313233343536373839404142messages: &#123;required: \"This field is required.\",remote: \"Please fix this field.\",email: \"Please enter a valid email address.\",url: \"Please enter a valid URL.\",date: \"Please enter a valid date.\",dateISO: \"Please enter a valid date (ISO).\",dateDE: \"Bitte geben Sie ein g眉ltiges Datum ein.\",number: \"Please enter a valid number.\",numberDE: \"Bitte geben Sie eine Nummer ein.\",digits: \"Please enter only digits\",creditcard: \"Please enter a valid credit card number.\",equalTo: \"Please enter the same value again.\",accept: \"Please enter a value with a valid extension.\",maxlength: $.validator.format(\"Please enter no more than &#123;0&#125; characters.\"),minlength: $.validator.format(\"Please enter at least &#123;0&#125; characters.\"),rangelength: $.validator.format(\"Please enter a value between &#123;0&#125; and &#123;1&#125; characters long.\"),range: $.validator.format(\"Please enter a value between &#123;0&#125; and &#123;1&#125;.\"),max: $.validator.format(\"Please enter a value less than or equal to &#123;0&#125;.\"),min: $.validator.format(\"Please enter a value greater than or equal to &#123;0&#125;.\")&#125;,如需要修改，可在js代码中加入：jQuery.extend(jQuery.validator.messages, &#123;required: \"必选字段\",remote: \"请修正该字段\",email: \"请输入正确格式的电子邮件\",url: \"请输入合法的网址\",date: \"请输入合法的日期\",dateISO: \"请输入合法的日期 (ISO).\",number: \"请输入合法的数字\",digits: \"只能输入整数\",creditcard: \"请输入合法的信用卡号\",equalTo: \"请再次输入相同的值\",accept: \"请输入拥有合法后缀名的字符串\",maxlength: jQuery.validator.format(\"请输入一个长度最多是 &#123;0&#125; 的字符串\"),minlength: jQuery.validator.format(\"请输入一个长度最少是 &#123;0&#125; 的字符串\"),rangelength: jQuery.validator.format(\"请输入一个长度介于 &#123;0&#125; 和 &#123;1&#125; 之间的字符串\"),range: jQuery.validator.format(\"请输入一个介于 &#123;0&#125; 和 &#123;1&#125; 之间的值\"),max: jQuery.validator.format(\"请输入一个最大为 &#123;0&#125; 的值\"),min: jQuery.validator.format(\"请输入一个最小为 &#123;0&#125; 的值\")&#125;);//推荐做法，将此文件放入messages_cn.js中，在页面中引入&lt;script src=\"../js/messages_cn.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 四、使用方法html: 1234567891011121314151617181920212223//head里需要加入#&lt;script src=\"../js/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt;#&lt;script src=\"../js/jquery.validate.js\" type=\"text/javascript\"&gt;&lt;/script&gt;#&lt;script src=\"./js/messages_cn.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;form action=\"\" method=\"post\" id=\"registerForm\" onsubmit=\"return toVaild()\"&gt; &lt;div&gt; &lt;input type=\"text\" name=\"userName\" class=\"username\" placeholder=\"您的用户名\" autocomplete=\"off\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"password\" name=\"userPw\" class=\"password\" placeholder=\"输入密码\" oncontextmenu=\"return false\" onpaste=\"return false\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"password\" name=\"confirm_password\" class=\"confirm_password\" placeholder=\"再次输入密码\" oncontextmenu=\"return false\" onpaste=\"return false\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"text\" name=\"userPhoneNum\" class=\"phone_number\" placeholder=\"输入手机号码\" autocomplete=\"off\" id=\"number\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"email\" name=\"userMail\" class=\"email\" placeholder=\"输入邮箱地址\" oncontextmenu=\"return false\" onpaste=\"return false\" /&gt; &lt;/div&gt; &lt;button id=\"submit\" type=\"submit\"&gt;注 册&lt;/button&gt;&lt;/form&gt; messages_cn.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//jquery.validate表单验证$(document).ready(function()&#123; //注册表单验证 $(\"#registerForm\").validate(&#123; rules:&#123; userName:&#123; required:true,//必填 minlength:3, //最少3个字符 maxlength:32,//最多20个字符 uName:true,//自定义的规则 /*remote:&#123; url:\"http://kouss.com/demo/Sharelink/remote.json\",//用户名重复检查，别跨域调用 type:\"post\", &#125;,*/ &#125;, userPw:&#123; required:true, minlength:3, maxlength:32, &#125;, userMail:&#123; required:true, email:true, &#125;, confirm_password:&#123; required:true, minlength:3, equalTo:'.password' &#125;, userPhoneNum:&#123; required:true, userPhoneNum:true,//自定义的规则 digits:true,//整数 &#125; &#125;, //错误信息提示 messages:&#123; userName:&#123; required:\"必须填写用户名\", minlength:\"用户名至少为3个字符\", maxlength:\"用户名至多为32个字符\", //remote: \"用户名已存在\", &#125;, userPw:&#123; required:\"必须填写密码\", minlength:\"密码至少为3个字符\", maxlength:\"密码至多为32个字符\", &#125;, userMail:&#123; required:\"请输入邮箱地址\", email: \"请输入正确的email地址\" &#125;, confirm_password:&#123; required: \"请再次输入密码\", minlength: \"确认密码不能少于3个字符\", equalTo: \"两次输入密码不一致\",//与另一个元素相同 &#125;, userPhoneNum:&#123; required:\"请输入手机号码\", digits:\"请输入正确的手机号码\", &#125;, &#125;, &#125;); // 字母和数字的验证 jQuery.validator.addMethod(\"uName\", function(value, element) &#123; var uName = /^([a-zA-Z0-9]+)$/; return this.optional(element) || (uName.test(value)); &#125;, \"用户名仅支持非空，数字和英文\"); //添加自定义验证规则 jQuery.validator.addMethod(\"userPhoneNum\", function(value, element) &#123; var length = value.length; var userPhoneNum = /^1[3456789]\\d&#123;9&#125;$/ return this.optional(element) || (length == 11 &amp;&amp; userPhoneNum.test(value)); &#125;, \"手机号码格式错误\");&#125;); 方法：$.validator.addMethod(name,function(value,element){ return true||false },message)； 参数： 第一个参数:用于type匹配的名称，自定义。 第二个参数:是一个function函数，决定了验证是否成功！里面是自定义验证。 第三个参数：当验证不成功时返回的提示错误信息。","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://quietair.gitee.io/tags/JQuery/"},{"name":"Html5","slug":"Html5","permalink":"https://quietair.gitee.io/tags/Html5/"},{"name":"Validate","slug":"Validate","permalink":"https://quietair.gitee.io/tags/Validate/"}]},{"title":"Ubuntu配置Tomcat改80端口报错","date":"2019-09-30T03:01:10.000Z","path":"2019/09/30/ubuntu-tomcat-80bug/","text":"本地环境：*ubuntu 18.04 LTS*jdk 1.8.0_181*tomcat 9.0.26 使用Ubuntu 18.04 环境部署 Java Web 应用，在配置 Tomcat时，发现8080端口没问题，改为80端口后就报错，然后自己网上找了些资料改去改来，不是[“http-nio-80”]，就APR，要么就拒绝连接。明天前面都用得好好的！后来又网上看了很多，才发现问题，然后就写这篇记忆下。 具体问题为在 Linux中对非root用户只能使用 1024 及以上的端口号，所以 80 端口对非 root 用户为禁用状态。第一种解决方法：使用 root 用户去配置并启动 Tomcat。这里讲的是第二种解决方法：使用 iptables 的转发功能，将 80 端口消息转发给 8080 端口。如果嫌麻烦，建议第一种。自己记住就行了。第二种教程如下： 一、前期工作1.查看系统是否安装防火墙：1$ whereis iptables 2.若已安装则下面显示为：12$ iptables: $ /sbin/iptables /etc/iptables.rules /usr/share/iptables /usr/share/man/man8/iptables.8.gz 3.否之，安装防火墙：1$ sudo apt-get install iptables 4.查看防火墙信息：1$ iptables -L -n 二、配置防火墙1.创建 iptables.rules 文件：1$ vi /etc/iptables.rules 2.按 i 进入编辑模式，添加以下规则：12345678910111213141516171819*filter:INPUT DROP [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]:syn-flood - [0:0]-A INPUT -i lo -j ACCEPT-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8443 -j ACCEPT-A INPUT -p icmp -m limit --limit 100/sec --limit-burst 100 -j ACCEPT-A INPUT -p icmp -m limit --limit 1/s --limit-burst 10 -j ACCEPT-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j syn-flood-A INPUT -j REJECT --reject-with icmp-host-prohibited-A syn-flood -p tcp -m limit --limit 3/sec --limit-burst 6 -j RETURN-A syn-flood -j REJECT --reject-with icmp-port-unreachableCOMMIT 1234522 端口为 SSH 默认端口 80 端口为 HTTP 默认端口 443 端口为 HTTPS 默认端口 8080 端口为 Tomcat 默认的 HTTP 端口 8443 端口为 Tomcat 默认的 HTTPS 端口 3.使防火墙规则生效：1$ iptables-restore &lt; /etc/iptables.rules 4.配置防火墙规则开机启动：*创建 iptables 文件： 1$ vi /etc/network/if-pre-up.d/iptables *添加以下内容： 12$ !/bin/bash$ iptables-restore &lt; /etc/iptables.rules 5.为 iptables 文件添加执行权限：1$ chmod +x /etc/network/if-pre-up.d/iptables 6.查看规则是否生效：1$ iptables -L -n 123456789101112131415161718192021222324Chain INPUT (policy DROP)target prot opt source destination ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHEDACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:80ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:443ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:8080ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:8443ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 limit: avg 100/sec burst 100ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 limit: avg 1/sec burst 10syn-flood tcp -- 0.0.0.0/0 0.0.0.0/0 tcp flags:0x17/0x02REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibitedChain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination Chain syn-flood (1 references)target prot opt source destination RETURN tcp -- 0.0.0.0/0 0.0.0.0/0 limit: avg 3/sec burst 6REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable 三、新增转发规则1.将 80 端口转发至 8080 端口1$ iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 2.查看 80 端口相关的转发规则1$ iptables -t nat -L -n | grep 80 返回： 1$ REDIRECT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 redir ports 8080 3.配置 Tomcat 服务端口为 8080*找到 Tomcat 安装目录下的 ../conf/server.xml 配置文件并且打开编辑如下内容，改为 8080 端口即可。*&lt;Connector port=”8080” protocol=”HTTP/1.1” 4.重启 Tomcat 服务，试一下应该就可以进行正常访问 80 端口了。1$ service tomcat restart 四、删除转发规则1.将转发规则以数字序号排列显示:1$ iptables -t nat -L -n --line-numbers Chain PREROUTING (policy ACCEPT) num target prot opt source destination 1 REDIRECT tcp – 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 redir ports 8080 2.删除 8080 端口对于的转发规则：1$ iptables -t nat -D PREROUTING 1 五、相关问题上述配置完成后，即可使用 IP 地址（或域名）+ 应用程序页面访问路径。如需直接使用 IP 地址（或域名）访问应用程序默认页面，应另外配置。另外，若参照上述配置时使用的是通过 域名 进行访问，则需要进行域名备案，同时需要指定访问的应用。当然可以暂且使用 域名:8080 进行访问，或是使用 https://域名 进行访问。 六、文章参考Ubuntu16.04配置Tomcat访问80端口","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://quietair.gitee.io/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"https://quietair.gitee.io/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://quietair.gitee.io/tags/Tomcat/"}]},{"title":"my first blog","date":"2019-09-27T07:53:52.000Z","path":"2019/09/27/my-first-blog/","text":"一、总结马上国庆了，在这几天里，总算把这个个人小站弄出来了！我太难了。最初是打算做个大的，买了域名，也用了服务器，后面也找了源码部署上去,效果也还行吧。不过服务器是免费的，那一套系统自己也没去改。想到后续搭建好了，需要更新等。就有点头疼。然后后面查资料的时候，看到了一些比较好的博客，然后发现他们基本都是基于GitHub搭建自己的免费个人博客。自己也有兴趣了，开始查资料，做准备。到了装环境的时候，简直要命，下一些包下了无数次还是失败，也尝试很多方法，然而没用。我都是两台电脑开工的。在Windows上试过，Ubuntu上试过，后来莫名其妙的好了，然后就开始设置主题等这些。最终结果还是好的，也完成了！！！自己还是很欣慰，然后将开始漫长的学习！ 二、关于后面自己毕竟还是太菜了，后面尽量会记录一些自己学习的啊，遇到的问题这些，用来记忆等！还会分享一些生活中有趣的！ 三、然后兴趣爱好这方面很广，就是技术更不上，希望后面能有提升！！！","tags":[{"name":"Share","slug":"Share","permalink":"https://quietair.gitee.io/tags/Share/"}]}]